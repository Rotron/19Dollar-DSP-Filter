#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>


// GUItool: begin automatically generated code
AudioPlayMemory          AudioPrompt;                   //xy=197.43333435058594,369
AudioInputAnalog         audioInput;                    //xy=210.43333435058594,121.99998474121094
AudioFilterFIR           myFilter;                      //xy=514.433349609375,218.99998474121094
AudioMixer4              audioOutputMixer;              //xy=862.433349609375,320
AudioOutputAnalog        audioOutput;                   //xy=1131.433349609375,329
AudioAnalyzePeak         audioInputPeak;                //xy=1140.433349609375,123
AudioConnection          patchCord1(AudioPrompt, 0, audioOutputMixer, 1);
AudioConnection          patchCord2(audioInput, myFilter);
AudioConnection          patchCord3(audioInput, audioInputPeak);
AudioConnection          patchCord4(myFilter, 0, audioOutputMixer, 0);
AudioConnection          patchCord5(audioOutputMixer, audioOutput);
// GUItool: end automatically generated code


/*
 * 
 * The GI1MIC $20 Dollar DSP Audio Filter
 * 
 * Visit https://gi1mic.github.io/ for information on how to use this code.
 * 
 * This project is for installing into a Yaesu FT-817 but should be easly 
 * modified to support any other radio.
 * 
 * Note: The code above is automatically generated by the Teensy Audio Design tool
 * at https://www.pjrc.com/teensy/gui/index.html - while it can be edited by hand 
 * the tool can import the code above allowing you to edit it inside a GUI tool.
 * 
 */

#include <Bounce.h>
#include "filters.h"
#include "AudioSampleMorse.h"
#include "AudioSampleSsb.h"
#include "AudioSamplePassthru.h"


// FIR filter selection (Toggle low to select next)
#define FILTER_PIN 0

// Installed filters ID's
#define PASSTHRU  0
#define MORSE     1
#define SSB       2

// Single filter structure
struct fir_filter {
  short *coeffs;
  short num_coeffs;
  short type;
};

// Structure to hold all our different filters
struct fir_filter fir_list[] = {
  {NULL,      0, PASSTHRU},                   // Passthru mode (special case)
  {bandpassMorse, bandpassMorseLen, MORSE},
  {bandpassSSB, bandpassSSBLen, SSB},
  {NULL,      1, NULL}                        // End of list marker
};

int fir_idx = 0;                              // index of current selected filter

Bounce b_filter   = Bounce(FILTER_PIN,15);    // debounce the filter switching pin
unsigned long last_time = millis();           // Timer var used for debugging

//---------------------------------------------------------------
void setup() {
  Serial.begin(9600);
  delay(300);

  pinMode(FILTER_PIN, INPUT);

  AudioMemory(6);
  
  // Initialize the filter
  myFilter.begin(fir_list[0].coeffs, fir_list[0].num_coeffs);

  audioOutput.analogReference(INTERNAL);
  
  // Initialize the mixer (Normally the totals should add to 1.0 max)
  audioOutputMixer.gain(0, 1.0);    // Filtered radio audio
  audioOutputMixer.gain(1, 1.0);    // Audio Prompt (we get away with this since this input is not normally active)
  audioOutputMixer.gain(2, 0);      // Not Used
  audioOutputMixer.gain(3, 0);      // Not used

  myFilter.begin(FIR_PASSTHRU, 0);  // Start in passthru mode

  Serial.println("setup done");
}


//---------------------------------------------------------------
void loop()
{

  b_filter.update();                    // read the button state
  
  if (b_filter.fallingEdge()) {         // On button press - switch to next filter in the list
    fir_idx++;

    // end of array, then loop
    if (fir_list[fir_idx].num_coeffs == 1) fir_idx = 0; 

    if (fir_list[fir_idx].type == MORSE) {
        myFilter.begin(fir_list[fir_idx].coeffs, fir_list[fir_idx].num_coeffs);
        speak(AudioSampleMorse);
        Serial.println("Morse");
    }
    if (fir_list[fir_idx].type == SSB) {
        myFilter.begin(fir_list[fir_idx].coeffs, fir_list[fir_idx].num_coeffs);
        speak(AudioSampleSsb);
        Serial.println("SSB");
    }
    if (fir_list[fir_idx].type == PASSTHRU) {
        myFilter.begin(FIR_PASSTHRU, 0);
        speak(AudioSamplePassthru);
        Serial.println("Passthru");
    }
  }

  // print debug and resource usage
  if (millis() - last_time >= 2500) {
    if ( audioInputPeak.available() ) {
        Serial.print("Peak input level = ");
        Serial.print(audioInputPeak.read());
        Serial.print(", ");    
    }
    Serial.print("Proc = ");
    Serial.print(AudioProcessorUsage());
    Serial.print(" (");    
    Serial.print(AudioProcessorUsageMax());
    Serial.print("),  Mem = ");
    Serial.print(AudioMemoryUsage());
    Serial.print(" (");    
    Serial.print(AudioMemoryUsageMax());
    Serial.println(")");
    last_time = millis();
  }
}

//---------------------------------------------------------------
void speak(const unsigned int* audioSample) {
        muteRadio();
        AudioPrompt.play(audioSample);
        do {delay(10);} while (AudioPrompt.isPlaying());
        unMuteRadio();
}

//---------------------------------------------------------------
void muteRadio() {
        audioOutputMixer.gain(0, 0.0); // Radio audio
}

//---------------------------------------------------------------
void unMuteRadio() {
        audioOutputMixer.gain(0, 1.0); // Radio audio

}
