#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>


// GUItool: begin automatically generated code
AudioPlayMemory          AudioPrompt;                   //xy=197.43333435058594,369
AudioInputAnalog         audioInput;                    //xy=210.43333435058594,121.99998474121094
AudioFilterFIR           myFilter;                      //xy=514.433349609375,218.99998474121094
AudioMixer4              audioOutputMixer;              //xy=862.433349609375,320
AudioOutputAnalog        audioOutput;                   //xy=1131.433349609375,329
AudioAnalyzePeak         audioInputPeak;                //xy=1140.433349609375,123
AudioConnection          patchCord1(AudioPrompt, 0, audioOutputMixer, 1);
AudioConnection          patchCord2(audioInput, myFilter);
AudioConnection          patchCord3(audioInput, audioInputPeak);
AudioConnection          patchCord4(myFilter, 0, audioOutputMixer, 0);
AudioConnection          patchCord5(audioOutputMixer, audioOutput);
// GUItool: end automatically generated code


/*
 * 
 * The GI1MIC $20 Dollar DSP Audio Filter
 * 
 * Visit https://gi1mic.github.io/ for information on how to use this code.
 * 
 * This project is for installing into a Yaesu FT-817 but should be easly 
 * modified to support any other radio.
 * 
 * Note: The code above is automatically generated by the Teensy Audio Design tool
 * at https://www.pjrc.com/teensy/gui/index.html - while it can be edited by hand 
 * the tool can import the code above allowing you to edit it inside a GUI tool.
 * 
 * Version 1.2
 * This update changes the Morse coefficients to an improved set based on a Windowed hamming FIR filter. 
 * See the https://gi1mic.github.io/ for a MATLAB simulation of the filter. 
 * Note: this is a very sharp filter - you may want to generate your own!
 * 
 * Version 1.1
 * Code Tidy-up 
 * Smaller (lower quality) voice prompts
 * Debug and FT817 mode controlled via defines
 * 
 * Version 1.0 
 * Initial release which had no version number
 */

#define DEBUG                               // Uncomment for debug information
#define FT817                               // Uncomment for FT817 else enable pullups for filter select via a button


#include <Bounce.h>
#include "filters.h"
#include "AudioSampleMorse.h"
#include "AudioSampleSsb.h"
#include "AudioSamplePassthru.h"


// FIR filter selection (Toggle low to select next)
#define SELECT_PIN    0                     // Pin to use for filter selection

// Installed filters ID's
#define PASSTHRU  0
#define MORSE     1
#define SSB       2

// Single filter structure
struct fir_filter {
  const short int *coeffs;
  short num_coeffs;
  short type;
};

// Structure to hold all our different filters
struct fir_filter fir_list[] = {
  {NULL,      0, PASSTHRU},                   // Passthru mode (special case)
  {bandpassMorse, bandpassMorseLen, MORSE},
  {bandpassSSB, bandpassSSBLen, SSB}
};

int fir_idx = 0;                              // index of current selected filter

Bounce filterSelect = Bounce(SELECT_PIN, 15); // debounce the filter switching pin
unsigned long last_time = millis();           // Timer var used for debugging

//---------------------------------------------------------------
void setup() {
  Serial.begin(115200);
  delay(300);

  AudioMemory(8);
  
  // Initialize the filter
  myFilter.begin(fir_list[0].coeffs, fir_list[0].num_coeffs);

  audioOutput.analogReference(INTERNAL);
  
  // Initialize the mixer (Normally the totals should add to 1.0 max)
  audioOutputMixer.gain(0, 1.0);    // Filtered radio audio
  audioOutputMixer.gain(1, 1.0);    // Audio Prompt (we get away with this since this input is not normally active)
  audioOutputMixer.gain(2, 0);      // Not Used
  audioOutputMixer.gain(3, 0);      // Not used

  myFilter.begin(FIR_PASSTHRU, 0);  // Start in passthru mode

  #ifdef FT817
    pinMode(SELECT_PIN, INPUT);
  #else
    pinMode(SELECT_PIN, INPUT_PULLUP);
  #endif

  Serial.println("setup done");
}


//---------------------------------------------------------------
void loop()
{

  filterSelect.update();                    // read the button state

  if (filterSelect.fallingEdge()) {         // On button press - switch to next filter in the list
    if (++fir_idx >= (sizeof(fir_list) / sizeof(fir_filter)))
      fir_idx = 0;                          // end of array, then loop

    if (fir_list[fir_idx].type == MORSE) {
        myFilter.begin(fir_list[fir_idx].coeffs, fir_list[fir_idx].num_coeffs);
        speak(AudioSampleMorse);
        Serial.println("Morse");
    }
    if (fir_list[fir_idx].type == SSB) {
        myFilter.begin(fir_list[fir_idx].coeffs, fir_list[fir_idx].num_coeffs);
        speak(AudioSampleSsb);
        Serial.println("SSB");
    }
    if (fir_list[fir_idx].type == PASSTHRU) {
        myFilter.begin(FIR_PASSTHRU, 0);
        speak(AudioSamplePassthru);
        Serial.println("Passthru");
    }
  }



#ifdef DEBUG
  // print debug and resource usage
  if (millis() - last_time >= 2500) {
    if ( audioInputPeak.available() ) {
        Serial.print("Peak input level = ");
        Serial.print(audioInputPeak.read());
        Serial.print(", ");    
    }
    Serial.print("Proc = ");
    Serial.print(AudioProcessorUsage());
    Serial.print(" (");    
    Serial.print(AudioProcessorUsageMax());
    Serial.print("),  Mem = ");
    Serial.print(AudioMemoryUsage());
    Serial.print(" (");    
    Serial.print(AudioMemoryUsageMax());
    Serial.println(")");
    last_time = millis();
  }
#endif
}

//---------------------------------------------------------------
void speak(const unsigned int* audioSample) {
        muteRadio();
        AudioPrompt.play(audioSample);
        do {delay(10);} while (AudioPrompt.isPlaying());
        unMuteRadio();
}

//---------------------------------------------------------------
void muteRadio() {
        audioOutputMixer.gain(0, 0.0); // Mute radio audio
}

//---------------------------------------------------------------
void unMuteRadio() {
        audioOutputMixer.gain(0, 1.0); // Unmute radio audio

}
