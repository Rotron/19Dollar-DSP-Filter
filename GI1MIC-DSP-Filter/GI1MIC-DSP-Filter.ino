/*
 * The GI1MIC $20 Dollar DSP Audio Filter
 * 
 * Visit https://gi1mic.github.io/ for information on how to use this code.
 * 
 * Email via GI1MIC at outlook.com
 * 
 * This project is for installing into a Yaesu FT-817 but should be easly 
 * modified to support any other radio.
 * 
 * Note: The code above is automatically generated by the Teensy Audio Design tool
 * at https://www.pjrc.com/teensy/gui/index.html - while it can be edited by hand 
 * the tool can import the code above allowing you to edit it inside a GUI tool.
 * 

 * Version 2.0
 * Moved from using pre-calculated to calculated filters
 * Added support for Teensy audio board for simplified integration with an amplified speaker this uses 
 *      a SD card fitted to the audio board to hold the speech files instead of the precompiled audio.
 * Added preliminary support for USB -> CAT interface for rig control
 * Added support for USB RX audio (Make sure you select Audio/Midi/Serial on the tools menu to compile without errors).
 * USB TX may be added but it will require a Teensy 3.5/3.6 as they have dual DAC's (OK, it may be possible on the 3.2 using PWM...)
 * 
 * Version 1.2
 * This update changes the Morse coefficients to an improved set based on a Windowed hamming FIR filter. 
 * See the https://gi1mic.github.io/ for a MATLAB simulation of the filter. 
 * Note: this is a very sharp filter - you may want to generate your own!
 * 
 * Version 1.1
 * Code Tidy-up 
 * Smaller (lower quality) voice prompts
 * Debug and FT817 mode controlled via defines
 * 
 * Version 1.0 
 * Initial release which had no version number
 */

#include <Audio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <SerialFlash.h>
#include <Encoder.h>
#include <Bounce.h>
#include "AudioSampleMorse.h"
#include "AudioSampleSsb.h"
#include "AudioSamplePassthru.h"
#include "AudioSampleDynamic.h"
#include "AudioSampleLowpass.h"
#include "AudioSampleHipass.h"
#include "dynamicFilters.h"
#include "cat.h"

// Uncomment to enable debug information doe not use with CAT!
#define DEBUG

// Display the calculated filter coeff in .coe format for import into MATLAB - do not use with CAT
// #define SHOWCOEFF

// Display performance information - do not use with CAT
// #define SHOWPERF

// Uncomment to compile code for Teensy 3.2 installed inside FT817 else uncomment SPEAKER
#define FT817                                

// Uncomment for use with amplified speaker this enables pullups for filter selection via a button
//#define SPEAKER                                


// Enable USB -> CAT Interface for rig control. CAT interface should be connected to Seril2
// See "cat.h" for more info
//#define CAT                                    


#ifdef FT817
//---------------------------------------------------------------------------------

// GUItool: begin automatically generated code
AudioInputUSB            inPC;           //xy=163.43333435058594,502.433349609375
AudioPlayMemory          AudioPrompt;    //xy=172.43333435058594,426
AudioInputAnalog         audioInput;     //xy=185.43333435058594,178
AudioFilterFIR           myFilter;       //xy=489.43333435058594,275
AudioMixer4              audioOutputMixer; //xy=837.4333343505859,377
AudioAnalyzeFFT256       fft256;         //xy=1091.433349609375,122
AudioAnalyzePeak         audioInputPeak; //xy=1115.433334350586,180
AudioOutputAnalog        audioOutput;    //xy=1116.433349609375,356
AudioOutputUSB           outPC;           //xy=1117.433349609375,456.433349609375
AudioConnection          patchCord1(inPC, 0, audioOutputMixer, 3);
AudioConnection          patchCord2(AudioPrompt, 0, audioOutputMixer, 1);
AudioConnection          patchCord3(audioInput, myFilter);
AudioConnection          patchCord4(audioInput, audioInputPeak);
AudioConnection          patchCord5(audioInput, fft256);
AudioConnection          patchCord6(myFilter, 0, audioOutputMixer, 0);
AudioConnection          patchCord7(audioOutputMixer, audioOutput);
AudioConnection          patchCord8(audioOutputMixer, 0, outPC, 0);
AudioConnection          patchCord9(audioOutputMixer, 0, outPC, 1);
// GUItool: end automatically generated code

//---------------------------------------------------------------------------------
#endif
#ifdef SPEAKER
//---------------------------------------------------------------------------------
// GUItool: begin automatically generated code
AudioInputI2S            audioInput;     //xy=207.43333435058594,199
AudioInputUSB            audioInPC;           //xy=207.43333435058594,496.433349609375
AudioPlayMemory          AudioPrompt;    //xy=212.43333435058594,407
AudioPlaySdWav           AudioPromptSD;  //xy=226.43333435058594,349
AudioFilterFIR           myFilter;       //xy=510.43333435058594,282
AudioMixer4              audioOutputMixer; //xy=858.4333343505859,384
AudioAnalyzeFFT256       fft256;         //xy=1111.433349609375,137
AudioAnalyzePeak         audioInputPeak; //xy=1136.433334350586,187
AudioOutputI2S           audioOutput;    //xy=1142.433334350586,391
AudioOutputUSB           audioOutPC;           //xy=1142.433349609375,455.433349609375
AudioConnection          patchCord1(audioInput, 0, myFilter, 0);
AudioConnection          patchCord2(audioInput, 0, audioInputPeak, 0);
AudioConnection          patchCord3(audioInput, 0, fft256, 0);
AudioConnection          patchCord4(audioInPC, 0, audioOutputMixer, 3);
AudioConnection          patchCord5(AudioPrompt, 0, audioOutputMixer, 2);
AudioConnection          patchCord6(AudioPromptSD, 0, audioOutputMixer, 1);
AudioConnection          patchCord7(myFilter, 0, audioOutputMixer, 0);
AudioConnection          patchCord8(audioOutputMixer, 0, audioOutput, 0);
AudioConnection          patchCord9(audioOutputMixer, 0, audioOutPC, 0);
AudioConnection          patchCord10(audioOutputMixer, 0, audioOutPC, 1);
AudioConnection          patchCord11(audioOutputMixer, 0, audioOutput, 1);
AudioControlSGTL5000     audioControl;   //xy=1136.433349609375,341
// GUItool: end automatically generated code

//---------------------------------------------------------------------------------
#endif


// FIR filter selection (Toggle low to select next)
#define SELECT_PIN    0                      // Pin to use for filter selection

#define NUM_COEFFICIENTS 200                  // Number of coefficients which must be an even number, 4 or higher and no greater than 200

// Installed filters ID's
#define PASSTHRU  0
#define MORSE     1
#define SSB       2
#define DYNAMIC   3


// Single filter structure
struct filter {
  const short int     filterID;
  const short int     filterType;
  double              freqLow;
  double              freqHigh;
  const short int     window;                       // Windows included are Blackman, Hanning, and Hamming
  const unsigned int *audioSample;             // Embedded speech or
  const String        filterName[25];               // Filename of WAV file on SD card
};

/*
 *   Structure to hold the required filters (Add, delete or modify as required) 
 *   
 *   ID,      FilterType,   Low Freq,      Hi Freq,    Window,  FilterName  
 */  
struct filter filterList[] = {
  {PASSTHRU,  BANDPASS,   60.0,  20000.0, W_HAMMING,  AudioSamplePassthru,  "Passthrough.wav"},
  {MORSE,     BANDPASS,  450.0,    950.0, W_HAMMING,  AudioSampleMorse,     "Morse.wav"},
  {SSB,       BANDPASS,  300.0,   2700.0, W_HAMMING,  AudioSampleSsb,       "SSB.wav"},
  {LOWPASS,   LOWPASS,  1000.0,      0.0, W_HAMMING,  AudioSampleLowpass,   "LowPass.wav"},
  {HIGHPASS,  HIGHPASS, 1000.0,      0.0, W_HAMMING,  AudioSampleHipass,    "HighPass.wav"}
};

unsigned int filterIndex = 0;                 // index to currently selected filter above
Bounce filterSelect = Bounce(SELECT_PIN, 15); // debounce the filter switching pin


/* 
 *  These define the Teensy Audio Shield interface
 */
#define SDCARD_CS_PIN    10
#define SDCARD_MOSI_PIN  7
#define SDCARD_SCK_PIN   14
Sd2Card card;


/* 
 *  Rotary encoder allows modification of the filters
 */
Encoder knob(1, 2);
long kPosition  = 0;

unsigned long last_time = millis();           // Timer var used for debugging

//---------------------------------------------------------------
void setup() {
  Serial.begin(115200);
  delay(300);

  AudioMemory(15);
  
  // Initialize with blank filter
  myFilter.begin(NULL, 0);

#ifdef FT817
  audioOutput.analogReference(INTERNAL);
#endif

#ifdef SPEAKER
    audioControl.enable();                  // Start the SGTL5000
    audioControl.volume(0.8);               // Set headset volume level
    audioControl.inputSelect(AUDIO_INPUT_LINEIN);

  SPI.setMOSI(SDCARD_MOSI_PIN);
  SPI.setSCK(SDCARD_SCK_PIN);
  boolean status = card.init(SPI_FULL_SPEED, SDCARD_CS_PIN);
  if (status) {
    Serial.println("SD card is connected :-)");
  } else {
    Serial.println("SD card is not connected or unusable :-(");
    return;
  }
  if (!(SD.begin(SDCARD_CS_PIN))) {
    // stop here, but print a message repetitively
    while (1) {
      Serial.println("Unable to access the SD card");
      delay(500);
    };
  };

#endif

  // Initialize the mixer (Normally the totals should add to 1.0 max)
  audioOutputMixer.gain(0, 1.0);    // Filtered radio audio
  audioOutputMixer.gain(1, 1.0);    // Audio Prompt (we get away with this since this input is not normally active)
  audioOutputMixer.gain(2, 1.0);    // Audio Prompt
  audioOutputMixer.gain(3, 0);      // Not used

  // Start in passthru mode
  audioFilter(fir_active, 
              NUM_COEFFICIENTS, 
              BANDPASS, 
              W_HAMMING, 
              60.0, 
              20000.0 );
                  
  #ifdef FT817
    pinMode(SELECT_PIN, INPUT);
  #else
    pinMode(SELECT_PIN, INPUT_PULLUP);
  #endif

  initCAT();

  Serial.println("setup done");
}



//---------------------------------------------------------------
void loop()
{

  filterSelect.update();                            // read the button state

  if (filterSelect.fallingEdge()) {                 // On button press - switch to next filter in the list
    filterIndex++;
    if (filterIndex >= (sizeof(filterList) / sizeof(filter)))
          filterIndex = 0;                          // end of array, then loop
    audioFilter(  fir_active, 
                  NUM_COEFFICIENTS, 
                  filterList[filterIndex].filterType, 
                  filterList[filterIndex].window, 
                  filterList[filterIndex].freqLow, 
                  filterList[filterIndex].freqHigh );
#ifdef FT817
    speak(filterList[filterIndex].audioSample);
#endif
#ifdef SPEAKER
    speakSD(filterList[filterIndex].filterName[0].c_str());
#endif
}


  // Rotary Encoder - move the centerpoint of the filter
  long newKnob;
  newKnob = knob.read();
  if (newKnob != kPosition) {
    int diff = (newKnob - kPosition) * 4;
    Serial.print("Knob = ");
    Serial.print(diff);
    Serial.println();

    filterList[filterIndex].freqLow  += diff;
    filterList[filterIndex].freqHigh += diff;
    audioFilter(fir_active, 
                NUM_COEFFICIENTS, 
                filterList[filterIndex].filterType, 
                filterList[filterIndex].window, 
                filterList[filterIndex].freqLow, 
                filterList[filterIndex].freqHigh );
    kPosition = newKnob;
  }


#ifdef SHOWPERF
  // print debug and resource usage
  if (millis() - last_time >= 2500) {
    if ( audioInputPeak.available() ) {
        Serial.print("Peak input level = ");
        Serial.print(audioInputPeak.read());
        Serial.print(", ");    
    }
    Serial.print("Proc = ");
    Serial.print(AudioProcessorUsage());
    Serial.print(" (");    
    Serial.print(AudioProcessorUsageMax());
    Serial.print("),  Mem = ");
    Serial.print(AudioMemoryUsage());
    Serial.print(" (");    
    Serial.print(AudioMemoryUsageMax());
    Serial.println(")");
    last_time = millis();
  }
#endif
    serviceCAT();
}


//---------------------------------------------------------------
void speak(const unsigned int* audioSample) {
        muteRadio();
        AudioPrompt.play(audioSample);
        do {delay(10);} while (AudioPrompt.isPlaying());
        unMuteRadio();
}

//---------------------------------------------------------------
void speakSD(const char *filename) {
#ifdef SPEAKER
        muteRadio();
   //     Serial.print("Playing file: ");
   //     Serial.println(filename);
        AudioPromptSD.play(filename);
        while (AudioPromptSD.isPlaying()) {
          delay(20);
        };
        unMuteRadio();
#endif
}

//---------------------------------------------------------------
void muteRadio() {
        audioOutputMixer.gain(0, 0.0); // Mute radio audio
}

//---------------------------------------------------------------
void unMuteRadio() {
        audioOutputMixer.gain(0, 1.0); // Unmute radio audio
}

//---------------------------------------------------------------
void lowpass(short h[], const int &N, const int &WINDOW, const double &fc) {
  wsfirLP(fir_tmp, N, WINDOW, fc );
  coeffConvert(fir_tmp, h, N);
  myFilter.begin(h, N);
}

//---------------------------------------------------------------
void highpass(short h[], const int &N, const int &WINDOW, const double &fc) {
  wsfirHP(fir_tmp, N, WINDOW, fc);
  coeffConvert(fir_tmp, h, N);
  myFilter.begin(h, N);
}

//---------------------------------------------------------------
void bandpass(short h[], const int &N, const int &WINDOW, const double &fc1, const double &fc2) {
  wsfirBP(fir_tmp, N, WINDOW, fc1, fc2 );
  coeffConvert(fir_tmp, h, N);
  myFilter.begin(h, N);
}

//---------------------------------------------------------------
void bandstop(short h[], const int &N, const int &WINDOW, const double &fc1, const double &fc2) {
  wsfirBS(fir_tmp, N, WINDOW, fc1, fc2 );
  coeffConvert(fir_tmp, h, N);
  myFilter.begin(h, N);
}

//---------------------------------------------------------------

void audioFilter(short h[], const int &N, const int &TYPE, const int &WINDOW, const double &fc1, const double &fc2) {
  switch (TYPE) {
      case LOWPASS:
                  Serial.print("LowPass Freq:");
                  Serial.println(fc1);
                  lowpass(h, N, WINDOW, fc1/44117);
                  break;
      case HIGHPASS:
                  Serial.print("HiPass Freq:");
                  Serial.println(fc1);
                  highpass(h, N, WINDOW, fc1/44117);
                  break;
      case BANDPASS:
                  Serial.print("BandPass LFreq:");
                  Serial.print(fc1);
                  Serial.print(" HFreq:");
                  Serial.println(fc2);
                  bandpass(h, N, WINDOW, fc1/44117, fc2/44117);
                  break;
      case BANDSTOP:
                  Serial.print("Bandstop LFreq:");
                  Serial.print(fc1);
                  Serial.print(" HFreq:");
                  Serial.println(fc2);
                  bandstop(h, N, WINDOW, fc1/44117, fc2/44117);
                  break;
      default:
                  Serial.println("Unknown");    
                  break;
  }                  
}


